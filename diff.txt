diff --git a/examples/broker.rs b/examples/broker.rs
index 72f3b8a..8861ef5 100644
--- a/examples/broker.rs
+++ b/examples/broker.rs
@@ -67,6 +67,7 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
                                 let mut success_codes = vec![];
                                 let guard = mqtt_id_lock.read().await;
                                 let mqtt_id: String = guard.clone();
+
                                 if mqtt_id != "".to_string() {
                                     for (filter, suboption) in subpacket.topic_filters {
                                         trace!("Subscribe Done!! ");
@@ -74,13 +75,14 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
                                         success_codes.push(SubackReasonCode::from(suboption.qos));
                                     }
                                 }
-
+                                let protocol_version =
+                                    SESSION_MANAGER.get_protocol_version(&mqtt_id);
                                 return Ok(response::Response::new(ControlPacket::SUBACK({
                                     Suback {
                                         packet_id: subpacket.packet_id,
                                         suback_properties: None,
                                         reason_codes: success_codes,
-                                        protocol_version: ProtocolVersion::new(0x05),
+                                        protocol_version: protocol_version.unwrap(),
                                     }
                                 })));
                             }
@@ -98,12 +100,23 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
                                             .value()
                                             .to_string(),
                                     );
-                                    for (sub_id, _option) in subed_clients {
+                                    let mut delivery_id = 1; // 配信用のパケットID生成
+                                    for (sub_id, option) in subed_clients {
+                                        let mut delivery_msg = pubpacket_clone_for_spawn.clone();
+
+                                        // 受信側のサブスクリプションQoSに合わせて配信
+                                        delivery_msg.qos = option.qos;
+                                        if option.qos == mqtt::QoS::QoS0 {
+                                            delivery_msg.packet_id = None;
+                                        } else {
+                                            delivery_msg.packet_id =
+                                                Some(mqtt::PacketId::new(delivery_id));
+                                            delivery_id += 1;
+                                        }
+
                                         let result = SESSION_MANAGER.send_by_mqtt_id(
                                             &sub_id,
-                                            ControlPacket::PUBLISH(
-                                                pubpacket_clone_for_spawn.clone(),
-                                            ),
+                                            ControlPacket::PUBLISH(delivery_msg),
                                         );
                                         if let Ok(()) = result {
                                             println!("Delivering to {:?}", sub_id);
@@ -154,10 +167,47 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
 
                             ControlPacket::PUBREL(pubrel_packet) => {
                                 trace!("pubrel!!!!!!!!!!");
-                                // PUBREL受信時の処理を追加する必要があります
                                 let packet_id = pubrel_packet.packet_id;
-                                // QoS2ステージングメッセージから該当メッセージを取り出す処理も必要（実装済みなら呼ぶ）
-                                //SESSION_MANAGER.remove_staging_packet(packet_id);
+
+                                // QoS2ステージングメッセージから該当メッセージを取り出して配信
+                                if let Ok(staged_publish) =
+                                    SESSION_MANAGER.fetch_packet(packet_id.clone())
+                                {
+                                    let topic_mgr = Arc::clone(&topic_mgr);
+                                    let delivery_publish = staged_publish.clone();
+
+                                    tokio::spawn(async move {
+                                        let subed_clients = topic_mgr.subed_id(
+                                            delivery_publish.topic_name.clone().value().to_string(),
+                                        );
+                                        let mut delivery_id = 1; // 配信用のパケットID生成
+                                        for (sub_id, option) in subed_clients {
+                                            let mut delivery_msg = delivery_publish.clone();
+
+                                            // 受信側のサブスクリプションQoSに合わせて配信
+                                            delivery_msg.qos = option.qos;
+                                            if option.qos == mqtt::QoS::QoS0 {
+                                                delivery_msg.packet_id = None;
+                                            } else {
+                                                delivery_msg.packet_id =
+                                                    Some(mqtt::PacketId::new(delivery_id));
+                                                delivery_id += 1;
+                                            }
+
+                                            let result = SESSION_MANAGER.send_by_mqtt_id(
+                                                &sub_id,
+                                                ControlPacket::PUBLISH(delivery_msg),
+                                            );
+                                            if let Ok(()) = result {
+                                                println!("QoS2 Delivering to {:?}", sub_id);
+                                            } else {
+                                                println!("QoS2 Error {:?}", sub_id);
+                                            }
+                                        }
+                                    });
+                                    // パケットをコミット（削除）
+                                    let _ = SESSION_MANAGER.commit_packet(packet_id.clone());
+                                }
 
                                 return Ok(response::Response::new(ControlPacket::PUBCOMP(
                                     mqtt::Pubcomp {
@@ -168,6 +218,24 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
                                     },
                                 )));
                             }
+                            ControlPacket::PUBREC(pubrec_packet) => {
+                                trace!("Received PUBREC from subscriber");
+                                // 受信者からのPUBRECに対してPUBRELで応答
+                                return Ok(response::Response::new(ControlPacket::PUBREL(
+                                    mqtt::Pubrel {
+                                        packet_id: pubrec_packet.packet_id,
+                                        pubrel_properties: None,
+                                        reason_code: None,
+                                        protocol_version: pubrec_packet.protocol_version,
+                                    },
+                                )));
+                            }
+                            ControlPacket::PUBCOMP(pubcomp_packet) => {
+                                trace!(
+                                    "Received PUBCOMP from subscriber - QoS2 handshake complete"
+                                );
+                                return Ok(response::Response::new(ControlPacket::NOOPERATION));
+                            }
                             other => {
                                 trace!("other {:?}", other);
                                 return Ok(response::Response::new(ControlPacket::NOOPERATION));
@@ -220,6 +288,8 @@ async fn main() -> Result<(), Box<dyn std::error::Error>> {
                         );
                         SESSION_MANAGER
                             .register_mqtt_id(client_id.clone(), incoming.client_id.clone());
+                        SESSION_MANAGER
+                            .set_protocol_version(&client_id.clone(), connack_data.version);
                         let connack_response = ConnackResponse::from(connack_data);
                         trace!("(connect) Connack response");
                         Ok(connack_response)
@@ -275,7 +345,7 @@ pub mod topic_manager {
             let mut ret = vec![];
             for topic_filter in topic_filters {
                 if self.is_match(&topic_filter, &topic) {
-                    if let Some(v2) = self.topic_map.get(&topic) {
+                    if let Some(v2) = self.topic_map.get(&topic_filter) {
                         ret.extend(v2.clone());
                     }
                 }
diff --git a/interoperability_pytest/paho_test b/interoperability_pytest/paho_test
--- a/interoperability_pytest/paho_test
+++ b/interoperability_pytest/paho_test
@@ -1 +1 @@
-Subproject commit 231d40588b8c043051486f281cd2bb6bf9b143f3
+Subproject commit 231d40588b8c043051486f281cd2bb6bf9b143f3-dirty
diff --git a/mqtt_coder/src/mqtt.rs b/mqtt_coder/src/mqtt.rs
index 9a40a9a..475d9bc 100644
--- a/mqtt_coder/src/mqtt.rs
+++ b/mqtt_coder/src/mqtt.rs
@@ -77,6 +77,10 @@ impl MqttPacket for ControlPacket {
             ControlPacket::PINGREQ(p) => p.decode_payload(buf, protocol_version),
             ControlPacket::PUBREL(p) => p.decode_payload(buf, protocol_version),
             ControlPacket::DISCONNECT(p) => p.decode_payload(buf, protocol_version),
+            // PUBACK, PUBREC, PUBCOMP have no payload
+            ControlPacket::PUBACK(_) => Ok(buf),
+            ControlPacket::PUBREC(_) => Ok(buf),
+            ControlPacket::PUBCOMP(_) => Ok(buf),
             _ => Err(MqttError::NotImplemented),
         }
     }
@@ -94,6 +98,26 @@ impl MqttPacket for ControlPacket {
             ControlPacket::UNSUBSCRIBE(p) => p.decode_variable_header(buf, start_pos, remaining_length, protocol_version),
             ControlPacket::PINGREQ(p) => p.decode_variable_header(buf, start_pos, remaining_length, protocol_version),
             ControlPacket::DISCONNECT(p) => p.decode_variable_header(buf, start_pos, remaining_length, protocol_version),
+            ControlPacket::PUBREL(p) => p.decode_variable_header(buf, start_pos, remaining_length, protocol_version),
+            // Simple variable header decoders for QoS packets
+            ControlPacket::PUBACK(p) => {
+                let (packet_id, next_pos) = mqtt::PacketId::try_from(buf, start_pos)?;
+                p.packet_id = packet_id;
+                p.protocol_version = protocol_version.unwrap_or_default();
+                Ok(next_pos)
+            },
+            ControlPacket::PUBREC(p) => {
+                let (packet_id, next_pos) = mqtt::PacketId::try_from(buf, start_pos)?;
+                p.packet_id = packet_id;
+                p.protocol_version = protocol_version.unwrap_or_default();
+                Ok(next_pos)
+            },
+            ControlPacket::PUBCOMP(p) => {
+                let (packet_id, next_pos) = mqtt::PacketId::try_from(buf, start_pos)?;
+                p.packet_id = packet_id;
+                p.protocol_version = protocol_version.unwrap_or_default();
+                Ok(next_pos)
+            },
             _ => Err(MqttError::NotImplemented),
         }
     }
@@ -104,6 +128,7 @@ impl MqttPacket for ControlPacket {
             ControlPacket::SUBACK(p) => p.encode_header(),
             ControlPacket::PUBACK(p) => p.encode_header(),
             ControlPacket::PUBREC(p) => p.encode_header(),
+            ControlPacket::PUBREL(p) => p.encode_header(),
             ControlPacket::PUBCOMP(p) => p.encode_header(),
             ControlPacket::UNSUBACK(p) => p.encode_header(),
             ControlPacket::PUBLISH(p) => p.encode_header(),
@@ -118,6 +143,7 @@ impl MqttPacket for ControlPacket {
             ControlPacket::SUBACK(p) => p.encode_payload_chunk(),
             ControlPacket::PUBACK(p) => p.encode_payload_chunk(),
             ControlPacket::PUBREC(p) => p.encode_payload_chunk(),
+            ControlPacket::PUBREL(p) => p.encode_payload_chunk(),
             ControlPacket::PUBCOMP(p) => p.encode_payload_chunk(),
             ControlPacket::UNSUBACK(p) => p.encode_payload_chunk(),
             ControlPacket::PUBLISH(p) => p.encode_payload_chunk(),
@@ -525,10 +551,16 @@ pub struct Puback {
     pub protocol_version: ProtocolVersion,
 }
 
-#[derive(PartialEq, Debug, Default, Clone)]
+#[derive(PartialEq, Debug, Clone, Default)]
 pub struct PubackProperties {
-    reason_string: Option<ReasonString>,
-    user_properties: Vec<UserProperty>,
+    pub reason_string: Option<ReasonString>,
+    pub user_properties: Vec<UserProperty>,
+}
+
+#[derive(PartialEq, Debug, Clone)]
+pub struct PubrelProperties {
+    pub reason_string: Option<ReasonString>,
+    pub user_properties: Vec<UserProperty>,
 }
 
 #[repr(u8)]
@@ -578,7 +610,7 @@ impl Puback {
         let mut encoded_property_length = Vec::new();
         let remaining_length;
         if self.protocol_version.value() >= 5 { /* MQTT5 */
-            if  let Some(_) = self.reason_code {
+            if let Some(_) = self.reason_code {
                 pro = self.puback_properties.clone().unwrap_or(PubackProperties::default()).build_bytes()?;
                 let property_length = pro.len();
                 encoded_property_length = encode_variable_bytes(property_length);
@@ -727,11 +759,6 @@ pub struct Pubrel {
     pub protocol_version: ProtocolVersion,
 }
 
-#[derive(PartialEq, Debug, Default)]
-struct PubrelProperties {
-    reason_string: Option<ReasonString>,
-    user_properties: Vec<UserProperty>,
-}
 
 impl PubrelProperties {
     fn new() -> Self {
@@ -744,12 +771,40 @@ impl PubrelProperties {
         self.user_properties
             .push(prop);
     }
+    
+    pub fn encode(&self) -> Result<Bytes, MqttError> {
+        let mut buf = BytesMut::new();
+        if let Some(c) = &self.reason_string {
+            let c = c.clone().into_inner();
+            buf.extend_from_slice(&[0x1f]);
+            let l: u16 = c.len().try_into().map_err(|_| MqttError::InvalidFormat)?;
+            buf.extend_from_slice(&l.to_be_bytes());
+            buf.extend_from_slice(c.as_bytes());
+        }
+        for v in &self.user_properties {
+            let v = v.clone().into_inner();
+            buf.extend_from_slice(&[0x26]);
+            let l: u16 = v.0.len().try_into().map_err(|_| MqttError::InvalidFormat)?;
+            buf.extend_from_slice(&l.to_be_bytes());
+            buf.extend_from_slice(v.0.as_bytes());
+            let l: u16 = v.1.len().try_into().map_err(|_| MqttError::InvalidFormat)?;
+            buf.extend_from_slice(&l.to_be_bytes());
+            buf.extend_from_slice(v.1.as_bytes());
+        }
+        Ok(buf.freeze())
+    }
+}
+
+impl Default for PubrelProperties {
+    fn default() -> Self {
+        Self::new()
+    }
 }
 
 
 #[repr(u8)]
 #[derive(Debug, PartialEq, Clone, Copy)]
-enum PubrelReasonCode {
+pub enum PubrelReasonCode {
     Success = 0x00,
     PacketIdentifierNotFound = 0x92,
 }
@@ -769,7 +824,7 @@ impl PubrelReasonCode {
     }
 }
 
-impl Pubrel {
+impl MqttPacket for Pubrel {
     fn decode_variable_header(
         &mut self,
         buf: &bytes::BytesMut,
@@ -828,6 +883,51 @@ impl Pubrel {
         // no payload
         Ok(buf)
     }
+    
+    fn encode_header(&self) -> Result<Bytes, MqttError> {
+        let mut pro = bytes::Bytes::new();
+        let mut encoded_property_length = Vec::new();
+        let remaining_length;
+        let omit = (self.reason_code == None) && (self.pubrel_properties == None);
+        // Properties
+        if self.protocol_version.value() >= 5 && !omit { /* MQTT5 */
+            pro = self.pubrel_properties.clone().unwrap_or(PubrelProperties::default()).encode()?;
+            let property_length = pro.len();
+            encoded_property_length = encode_variable_bytes(property_length);
+            remaining_length = 2 /* id */ + 1 /* reason */ + encoded_property_length.len() + pro.len();
+         } else {
+            /* MQTT3 もしくは自明な場合(omit)では常に2byteとなる*/
+            remaining_length = 2;
+        }
+        let encoded_remaining_length = encode_variable_bytes(remaining_length);
+
+        let mut buf = BytesMut::with_capacity(remaining_length + 4 /* fix header */);
+        /* Fixed header */
+        buf.put_u8(0b01100010); // PUBREL fixed flags
+        /* remaining length */
+
+        buf.extend_from_slice(&encoded_remaining_length);
+        /* Variable header */
+        // Packet ID
+        buf.put_u16(self.packet_id.value());
+
+        if self.protocol_version.value() >= 5 && !omit {
+            if let Some(reason_code) = self.reason_code {
+                /* Reason code */
+                buf.put_u8(reason_code as u8);
+                /* Properties Length */
+                buf.extend_from_slice(&encoded_property_length);
+                /* Properties */
+                buf.extend_from_slice(&pro);
+            }
+
+        }
+        Ok(buf.freeze())
+    }
+    
+    fn encode_payload_chunk(&self) -> Result<Option<Bytes>, MqttError> {
+        Ok(None)
+    }
 }
 
 
@@ -1262,7 +1362,7 @@ pub enum SubackProperty {
 }
 
 #[derive(Debug, PartialEq, Clone)]
-struct ReasonString(String);
+pub struct ReasonString(String);
 impl ReasonString {
     fn try_from(
         buf: &bytes::BytesMut,
@@ -1406,6 +1506,10 @@ impl TopicName {
 #[derive(Debug, PartialEq, Clone, Default)]
 pub struct PacketId(u16);
 impl PacketId {
+    pub fn new(id: u16) -> Self {
+        PacketId(id)
+    }
+    
     fn try_from(
         buf: &bytes::BytesMut,
         start_pos: usize,
@@ -2824,7 +2928,7 @@ pub mod decoder {
     use crate::mqtt::Unsubscribe;
 
     use super::{
-        decode_lower_fixed_header, decode_variable_length, Connect, ControlPacket, Disconnect, MqttError, ProtocolVersion, Publish, Pubrel, Subscribe
+        decode_lower_fixed_header, decode_variable_length, Connect, ControlPacket, Disconnect, MqttError, ProtocolVersion, Publish, Pubrel, Subscribe, Puback, Pubrec, Pubcomp
     };
     // (, next_pos size)
     pub fn decode_fixed_header(
@@ -2874,6 +2978,53 @@ pub mod decoder {
                     remaining_length,
                 ));
             },
+            // PUBACK
+            0b0100 => {
+                let (remaining_length, next_pos) = decode_variable_length(buf, start_pos + 1)?;
+                return Ok((
+                    ControlPacket::PUBACK(Puback {
+                        ..Default::default()
+                    }),
+                    next_pos,
+                    remaining_length,
+                ));
+            }
+            // PUBREC
+            0b0101 => {
+                let (remaining_length, next_pos) = decode_variable_length(buf, start_pos + 1)?;
+                return Ok((
+                    ControlPacket::PUBREC(Pubrec {
+                        ..Default::default()
+                    }),
+                    next_pos,
+                    remaining_length,
+                ));
+            }
+            // PUBREL
+            0b0110 => {
+                if buf[0] != 0b01100010 {
+                    return Err(MqttError::InvalidFormat);
+                }
+                let (remaining_length, next_pos) = decode_variable_length(buf, start_pos + 1)?;
+                return Ok((
+                    ControlPacket::PUBREL(Pubrel {
+                        ..Default::default()
+                    }),
+                    next_pos,
+                    remaining_length,
+                ));
+            }
+            // PUBCOMP
+            0b0111 => {
+                let (remaining_length, next_pos) = decode_variable_length(buf, start_pos + 1)?;
+                return Ok((
+                    ControlPacket::PUBCOMP(Pubcomp {
+                        ..Default::default()
+                    }),
+                    next_pos,
+                    remaining_length,
+                ));
+            }
             // SUBSCRIBE
             0b1000 => {
                 if buf[0] != 0b10000010 {
@@ -2904,20 +3055,6 @@ pub mod decoder {
                     remaining_length
                 ))
             }
-            // PUBREL
-            0b0110 => {
-                if buf[0] != 0b01100010 {
-                    return Err(MqttError::InvalidFormat);
-                }
-                let (remaining_length, next_pos) = decode_variable_length(buf, start_pos + 1)?;
-                return Ok((
-                    ControlPacket::PUBREL(Pubrel {
-                        ..Default::default()
-                    }),
-                    next_pos,
-                    remaining_length,
-                ))
-            }
             _control_type => return Err(MqttError::InvalidFormat),
         };
     }
@@ -3872,5 +4009,3 @@ fn mqtt5_subscribe_full_parse() {
     
 
 }
-
-
diff --git a/src/aqua/connection.rs b/src/aqua/connection.rs
index 5b62c96..3f3276e 100644
--- a/src/aqua/connection.rs
+++ b/src/aqua/connection.rs
@@ -56,6 +56,7 @@ where
     write_buffer: BytesMut,
     decoder: decoder::Decoder,
     encoder: encoder::Encoder,
+    protocol_version: Option<mqtt::ProtocolVersion>,
 }
 
 #[derive(Default)]
@@ -106,6 +107,7 @@ where
             write_buffer: BytesMut::new(),
             decoder: decoder::Decoder::new(),
             encoder: encoder::Encoder::new(),
+            protocol_version: None,
         }
     }
 
@@ -175,6 +177,7 @@ where
                     Poll::Ready(Ok(req)) => {
                         if let ControlPacket::CONNECT(ref packet) = req.body {
                             // here ??
+                            this.protocol_version = Some(packet.protocol_ver);
                             this.decoder.set_protocol_version(Some(packet.protocol_ver));
                             req
                         } else {
diff --git a/src/aqua/connection/session_manager.rs b/src/aqua/connection/session_manager.rs
index 0e01ac9..0d965b8 100644
--- a/src/aqua/connection/session_manager.rs
+++ b/src/aqua/connection/session_manager.rs
@@ -1,6 +1,8 @@
 use crate::aqua::connection::response::Response;
 use dashmap::DashMap;
-use mqtt_coder::mqtt::{ClientId, ControlPacket, MqttError, MqttPacket, PacketId, Publish, QoS};
+use mqtt_coder::mqtt::{
+    self, ClientId, ControlPacket, MqttError, MqttPacket, PacketId, Publish, QoS,
+};
 use std::sync::Arc;
 use tokio::sync::mpsc;
 use tokio::sync::mpsc::error::TrySendError;
@@ -30,6 +32,7 @@ pub struct SessionManager {
     by_mqtt_id: Arc<DashMap<String, Uuid>>,
     by_client_mqtt: Arc<DashMap<Uuid, String>>,
     qos_tmp: Arc<DashMap<u16, (Publish, QoS)>>,
+    mqtt_version: Arc<DashMap<String, mqtt::ProtocolVersion>>,
 }
 
 impl SessionManager {
@@ -39,6 +42,7 @@ impl SessionManager {
             by_mqtt_id: Arc::new(DashMap::new()),
             by_client_mqtt: Arc::new(DashMap::new()),
             qos_tmp: Arc::new(DashMap::new()),
+            mqtt_version: Arc::new(DashMap::new()),
         }
     }
 
@@ -118,4 +122,12 @@ impl SessionManager {
             .get(client_id)
             .map(|r| r.value().clone())
     }
+    pub fn get_protocol_version(&self, mqtt_id: &str) -> Option<mqtt::ProtocolVersion> {
+        self.mqtt_version
+            .get(mqtt_id)
+            .map(|entry| entry.value().clone())
+    }
+    pub fn set_protocol_version(&self, mqtt_id: &str, version: mqtt::ProtocolVersion) {
+        self.mqtt_version.insert(mqtt_id.to_string(), version);
+    }
 }
